# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/10_simulation.ipynb (unless otherwise specified).

__all__ = ['generate_cell', 'simulate_cells']

# Cell
import os
import numpy as np
import pandas as pd
import scipy

from .config import *
from .loglike import *
from .exposure import *
from .cells import *
from .lightcurve import *
from .weights import get_weight_hist

# Cell
import numbers
from scipy.stats import uniform
class _Sampler():
    """ Sample an arbitrary function or histogram

    - func -- a function, a histogram, or a fixed value<br>
        If a function, must be positive definite.<br>
        Assume histogram bins are 0 to 1.
    - a,b  -- limits (default 0,1)
    - n    -- table size (ignored if a histogram or value)

    """

    def __init__(self, func, limits=(0,1), n=100):

        a,b = limits
        self.x = np.linspace(a,b,n+1) # bin edges
        dx = (b-a)/(n)/2
        self.deltafun=None

        if callable(func):
            # A function
            # evaluate at bin centers
            y = np.array([func(t-dx) for t in self.x])
            if np.any(y<0) or np.sum(y)==0:
                raise ValueError('Function is not positive definite')
        elif isinstance(func, numbers.Number):
            # a single value, or delta function
            self.deltafun = func
            if  func<0 or func>1:
                raise ValueError('Value not in range [0,1]')
            self.mean=func
            return
        else:
            n = len(func)
            self.x = np.linspace(a,b,n)
            y = func
        cy = np.cumsum(y)
        d = cy[-1]-cy[0]
        self.sy = (cy-cy[0])/d

        self.mean = np.sum( (self.x-dx) * y) / d

    def _evaluate(self, r):
        """evaluate inverse integral. expect 0<r<1 """
        return np.interp(r, self.sy, self.x)

    def __call__(self, size):
        """Generate `size` values
        """
        if self.deltafun: return np.full(size, self.deltafun)

        return self._evaluate(uniform.rvs(size=size))

# Cell
class _WeightGenerator(_Sampler):
    """Generate a set of weights

    - `func` -- nominal weight distribution function, evaluated on (0,1)
    - `alpha, beta` -- (default 0,0). Values for $\\alpha$, $\\beta$.

    """
    def __init__(self, func, alpha=0, beta=0, n=100):
        if alpha==0 and beta==0:
            fprime = func
        else:
            # weight the function
            fprime = lambda w: func(w) * ( 1 + alpha*w + beta*(1-w) )
        super().__init__( fprime, limits=(0,1),  n=n)


# Cell
def generate_cell(wfun, mu, alpha=0, beta=0):
    """ Generate a cell

    - `wfun` -- weight function, or histogram.
        Defined on (0,1)
    - `mu` -- number of expected weights, on average
    - `alpha`, `beta`  -- default 0,0; values for $\\alpha$ and  $\\beta$ for this cell

    Returns a dict with:
    - `n` -- actual generated number of weights, from Poisson
    - `w` -- array of weights
    - `S, B` -- expected values for $\sum w$ and $\sum(1-w)$, calulated from wfun
    """
    from scipy import stats

    wgen_nominal = _WeightGenerator(wfun)
    wgen_cell =wgen_nominal if alpha==0 and beta==0 else _WeightGenerator(wfun, alpha, beta)

    # adjust expected number of events:
    wbar = wgen_nominal.mean
    mu_cell = mu * (1+alpha*wbar+beta*(1-wbar))

    # the weight array
    n = stats.poisson.rvs(mu_cell )
    w = wgen_cell(n)

    S = wgen_nominal.mean * mu
    B = mu-S

    return dict(
        n=n,
        w=np.array(w, np.float32), #np.uint8),
        S=S,
        B=B,
    )

# Cell
def simulate_cells(config, source, wdist=None, source_flux=lambda t: 100):
    """

    - `source` -- a PointSource object, use to get exposure at its position and weight distribution
    - `wdist`   -- a weight function or histogram; if None, get the source distribution
    - `source_flux` -- function of MJD time for the counts/day; default 100/day

    """
    fexp, bins = get_binned_exposure(config, source)

    cells=[]
    wdist = wdist or get_weight_hist(config, source)
    for i, e in enumerate(fexp):
        a,b = bins[i:i+2]
        t, tw = (a+b)/2, b-a
        mu = source_flux(t)*tw *e

        cell = dict(t=t, tw=tw, e=e)
        cell.update(generate_cell(wdist, mu))

        cells.append(cell)
    return pd.DataFrame(cells)