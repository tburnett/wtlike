# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_exposure.ipynb (unless otherwise specified).

__all__ = ['add_exposure_to_events', 'sec_per_day', 'generate_exposure']

# Cell
import os, sys
import numpy as np
import pandas as pd
from .config import *
from .effective_area import *

# Internal Cell

def contiguous(start, stop, min_gap=2, ):
    assert len(start)==len(stop)
    ssint = np.empty(2*len(start), float)
    ssint[0::2] = start
    ssint[1::2] = stop

    # Tag the (stpp,start) pairs < 10 sec as  not adjacent
    not_adjacent = np.diff(ssint)[1::2] > min_gap ;

    # make a mask, keep ends
    mask = np.empty(len(ssint), bool)
    mask[0] = mask[-1] = True
    #

    # insert into mask -- keep only the (stop,start) pairs  which are not adjacent
    mask[1:-2:2] = not_adjacent
    mask[2:-1:2] = not_adjacent

    # apply mask, split into start and stop
    keep = ssint[mask]
    return keep

# Cell
sec_per_day = 24*3600

def add_exposure_to_events(config, exposure, photons):
    """
    Modifies the photon DF to add column "tau"
    Returns DataFrame runs

    """
    # get interleaved start/stop pairs for contiguous intervals
    estop = exposure.stop.values
    etime = estart =exposure.start.values

    run_times = contiguous(estart, estop, min_gap=10/sec_per_day)
    fermi_start = run_times[0]
    fermi_stop = run_times[-1]
    if config.verbose>1:
        print(f'Found {len(run_times)//2:,} contiguous intervals, interpret as runs'
              f' from {UTC(fermi_start)[:10]} to {UTC(fermi_stop)[:10]}')

    ### Determine run exposures
    vexp = exposure.exp.values /1e4 # exposure per FT2 interval -- in m^2
    cumexp = np.insert(np.cumsum(vexp), 0,0)
    if config.verbose>1: print(f'Total exposure: {cumexp[-1]*1e-6:.3f}  m^2 Ms')

    run_index = np.searchsorted(estart, run_times)
    run_start_exp = cumexp[run_index][0::2]

#     run_exp_diff = np.diff(run_start_exp)

    ### Assign Event exposure from event times

    if config.verbose>1:
        print(f'Examine {len(photons):,} photons to add exposure.')
        print(f'Input:\n{photons.head()}')
    event = photons#['time weight'.split()].copy()
    event_exposure = cumexp[np.searchsorted(estart, event.time)]


    event.loc[:,'tau'] = np.diff(np.insert(event_exposure,0,0))
    if config.verbose>2:
        print(f'Added tau:\n{photons.info()}')

    return pd.DataFrame(
        dict(time=run_times[0::2],
             exp=run_start_exp),
    )

# Cell
def generate_exposure(config,  livetime, pcosine):
    """return exposure calculated for each pair in livetime and cosines arrays

    uses effective area
    """
    from scipy.integrate import simps
    assert len(livetime)==len(pcosine), 'expect equal-length arrays'

    # get a set of energies and associated weights from a trial spectrum

    emin,emax = config.energy_range
    loge1=np.log10(emin); loge2=np.log10(emax)

    edom=np.logspace(loge1, loge2, int((loge2-loge1)*config.bins_per_decade+1))
    if config.verbose>1:
        print(f'Calculate exposure using the energy domain'\
              f' {emin}-{emax} {config.bins_per_decade} bins/decade' )
    base_spectrum = eval(config.base_spectrum) #lambda E: (E/1000)**-2.1
    assert base_spectrum(1000)==1.
    wts = base_spectrum(edom)

    # effectivee area function from
    ea = EffectiveArea(file_path=config.wtlike_data/'aeff_files')

    # a table of the weighted for each pair in livetime and pcosine arrays
    rvals = np.empty([len(wts),len(pcosine)])
    for i,(en,wt) in enumerate(zip(edom,wts)):
        faeff,baeff = ea([en],pcosine)
        rvals[i] = (faeff+baeff)*wt

    aeff = simps(rvals,edom,axis=0)/simps(wts,edom)
    return (aeff*livetime)