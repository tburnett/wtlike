# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_exposure.ipynb (unless otherwise specified).

__all__ = ['BaseExposure', 'KerrExposure', 'SourceExposure', 'time_bin_edges', 'sc_data_selection', 'binned_exposure']

# Cell
import pandas as pd
import numpy as np

from .config import (Config, UTC, MJD)
from .effective_area import EffectiveArea

# Cell
def _sc_process(config, source, sc_data):

    """

    - sec_data -- DF constructedted from FT2.


    Return: a DF with the S/C data for the source direction, wtih cos theta and zenith cuts

    columns:
    - start, stop, livetime -- from the FT2 info
    - cos_theta -- angle between bore and direction
    - exp -- effective area at angle wighted by a default spectral function, times livetime

    """

    # calculate cosines with respect to sky direction
    ra_r,dec_r = np.radians(source.ra), np.radians(source.dec)
    sdec, cdec = np.sin(dec_r), np.cos(dec_r)

    def cosines( ra2, dec2):
        ra2_r =  np.radians(ra2.values)
        dec2_r = np.radians(dec2.values)
        return np.cos(dec2_r)*cdec*np.cos(ra_r-ra2_r) + np.sin(dec2_r)*sdec

    pcosines = cosines(sc_data.ra_scz,    sc_data.dec_scz)
    zcosines = cosines(sc_data.ra_zenith, sc_data.dec_zenith)
    # mask out entries too close to zenith, or too far away from ROI center
    mask =   (pcosines >= config.cos_theta_max) & (zcosines>=np.cos(np.radians(config.z_max)))
    if config.verbose>1:
        print(f'\tFound {len(mask):,} S/C entries:  {sum(mask):,} remain after zenith and theta cuts')
    dfm = sc_data.loc[mask,:]
    livetime = dfm.livetime.values
    return livetime, pcosines[mask]



# Cell
from abc import abstractmethod

class BaseExposure(object):
    """
    Base class for implementing exposure calculation
    """

    def __init__(self, config, source):

        self.config = config
        self.source = source
        self.Aeff = EffectiveArea(file_path=config.wtlike_data/'aeff_files')
        self.setup()

    @abstractmethod
    def setup(self):
        pass

    def __call__(self, sc_data):
        """
        Apply to a SC data set
        - sc_data -- DF with start,stop, livetime

        Returns:

        array of esposures for the input sc_data intervals

        """
        # get SC info for this source
        livetime, pcosine = _sc_process(self.config, self.source, sc_data)

        # as set by self.setup -- also serl.back_min
        edom = self.edom
        wts = self.wts #self(edom)

        # a table of the weights for each pair in livetime and pcosine arrays
        rvals = np.empty([len(wts),len(pcosine)])

        for i, (en,wt) in enumerate(zip(edom,wts)):
            faeff, baeff = np.array(self.Aeff( [en], pcosine ))
            if en>self.back_min:
                rvals[i] = (faeff+baeff)*wt # note that adds front and back exposure
            else:
                rvals[i] = faeff * wt # only front

        from scipy.integrate import simpson
        aeff = simpson(rvals, edom,axis=0) / simpson(wts,edom)

        return aeff*livetime

class KerrExposure(BaseExposure):

    def setup(self):

        """set up energy domain, evaluate fluxes
           This is the Kerr version
        """

        def energy_domain(config):
            emin,emax = config.energy_range
            loge1=np.log10(emin); loge2=np.log10(emax)
            return np.logspace(loge1, loge2, int((loge2-loge1)*config.bins_per_decade+1))

        self.edom = energy_domain(self.config)

        spectrum = eval(self.config.base_spectrum) #lambda E: (E/1000)**-2.1

        self.wts = spectrum(self.edom)

        # the threshold for including Back events
        self.back_min=0

# Cell
class SourceExposure(BaseExposure):
    """
    BaseExposure subclass that uses the source spectrum applied only to used bands
    """

    def setup(self):
        # set up weighted exposure using bands actually used, and actual flux

        wtdict = self.source.wtman.wt_dict
        bandids = np.array(list(wtdict.keys()))

        self.wts = np.array([wtdict[key]['flux'] for key in bandids if key%2==0])
        self.edom = self.config.energy_bins[:len(self.wts)]
        self.back_min = 300 # wired in--should check?

        if self.config.verbose>1:
            print(f'Set up flux-weigted exposure for {self.source.name}')

# Cell
def time_bin_edges(config, exposure, tbin=None):
    """Return an interleaved array of start/stop values

    tbin: an array (a,b,d), default config.time_bins

    interpretation of a, b:

        if > 50000, interpret as MJD
        if <0, back from stop
        otherwise, offset from start

    d : if positive, the day bin size
        if 0; return contiguous bins


    """
    # nominal total range, MJD edges
    start = np.round(exposure.start.values[0])
    stop =  np.round(exposure.stop.values[-1])

    a, b, step = tbin if tbin is not None else config.time_bins


    if a>50000: start=a
    elif a<0: start = stop+a
    else : start += a


    if b>50000: stop=b
    elif b>0: stop = start+b
    else: stop += b

    if step<=0:
        return contiguous_bins(exposure.query(f'{start}<start<{stop}'),)

    # adjust stop
    nbins = int((stop-start)/step)
    assert nbins>0, 'Bad binning: no bins'
    stop = start+(nbins)*step
    u =  np.linspace(start,stop, nbins+1 )

    # make an interleaved start/stop array
    v = np.empty(2*nbins, float)
    v[0::2] = u[:-1]
    v[1::2] = u[1:]
    return v


# Cell
def sc_data_selection(config, source, sc_df):

    """
    Return a DF with the S/C data for the source direction, wtih cos theta and zenith cuts

    columns:
    - start, stop, livetime -- from the FT2 info
    - cos_theta -- angle between bore and direction
    - exp -- effective area at angle wighted by a default spectral function, times livetime

    """

    # calculate cosines with respect to sky direction
    sc = source
    ra_r,dec_r = np.radians(sc.ra), np.radians(sc.dec)
    sdec, cdec = np.sin(dec_r), np.cos(dec_r)

    def cosines( ra2, dec2):
        ra2_r =  np.radians(ra2.values)
        dec2_r = np.radians(dec2.values)
        return np.cos(dec2_r)*cdec*np.cos(ra_r-ra2_r) + np.sin(dec2_r)*sdec

    pcosines = cosines(sc_df.ra_scz,    sc_df.dec_scz)
    zcosines = cosines(sc_df.ra_zenith, sc_df.dec_zenith)
    # mask out entries too close to zenith, or too far away from ROI center
    mask =   (pcosines >= config.cos_theta_max) & (zcosines>=np.cos(np.radians(config.z_max)))
    if config.verbose>1:
        print(f'\tFound {len(mask):,} S/C entries:  {sum(mask):,} remain after zenith and theta cuts')
    dfm = sc_df.loc[mask,:]
    livetime = dfm.livetime.values

    exp = KerrExposure(config, source)(sc_df)
    exp2= SourceExposure(config, source)(sc_df)

    return  pd.DataFrame(
        dict(
            start=sc_df.start[mask],
            stop=sc_df.stop[mask],
            livetime=livetime,
            cos_theta=pcosines[mask],
            exp=exp,
            exp2=exp2,
            ),
        )

# Cell
def binned_exposure(config, exposure, time_edges):
    """Bin the exposure in to cells

    - exposure -- A DataFrame derived from FT2
    - time_bins: list of edges, an interleaved start/stop array


    Returns:

    An array of exposure integrated over each time bin. Assumes that the time bins
    are contained within the exposure.

    it is interleaved, client must apply [0::2] selection. (why not do it here?)

    """

    # get exposure calculation
    exp   =exposure.exp.values
    estart= exposure.start.values
    estop = exposure.stop.values

    # determine bins,

    #use cumulative exposure to integrate over larger periods
    cumexp = np.concatenate(([0],np.cumsum(exp)) )

    # get index into tstop array of the bin edges
    edge_index = np.searchsorted(estop, time_edges)

    # return the exposure integrated over the intervals
    cum = cumexp[edge_index]

    # difference is exposure per interval
    bexp = np.diff(cum)
#     if config.verbose>1:
#         print(f'exposure per bin:\n{pd.Series(bexp).describe(percentiles=[])}')
    return bexp